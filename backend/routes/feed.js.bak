const express = require('express');
const router = express.Router();
const { Pool } = require('pg');
const { authenticateToken } = require('../middleware/auth');
const { successResponse, errorResponse } = require('../utils/responseFormatter');

const pool = new Pool({
  host: process.env.POSTGRES_HOST || '    
    res.json(successResponse(stats, 'Estatísticas do feed obtidas com sucesso'));
  } catch (error) {
    console.error('Erro ao buscar estatísticas:', error);
    res.status(500).json(errorResponse('Erro interno do servidor', error.message));
  }
});

// ====== ROTAS DE COMENTÁRIOS ======

// Listar comentários de um post
router.get('/:postId/comentarios', authenticateToken, async (req, res) => {
  try {
    const { postId } = req.params;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;

    const result = await pool.query(`
      SELECT 
        c.id,
        c.post_id,
        c.autor_id,
        c.autor_nome,
        c.autor_foto,
        c.conteudo,
        c.data_criacao,
        c.data_atualizacao,
        u.foto_perfil
      FROM comentarios_feed c
      LEFT JOIN usuarios u ON c.autor_id = u.id
      WHERE c.post_id = $1 AND c.ativo = true
      ORDER BY c.data_criacao ASC
      LIMIT $2 OFFSET $3
    `, [postId, limit, offset]);

    const countResult = await pool.query(
      'SELECT COUNT(*) FROM comentarios_feed WHERE post_id = $1 AND ativo = true',
      [postId]
    );

    const total = parseInt(countResult.rows[0].count);
    const totalPages = Math.ceil(total / limit);

    res.json(successResponse(
      result.rows.map(formatObjectDates), 
      'Comentários obtidos com sucesso',
      total,
      { page, limit, totalPages }
    ));
  } catch (error) {
    console.error('Erro ao buscar comentários:', error);
    res.status(500).json(errorResponse('Erro interno do servidor', error.message));
  }
});

// Criar novo comentário
router.post('/:postId/comentarios', authenticateToken, async (req, res) => {
  try {
    const { postId } = req.params;
    const { conteudo } = req.body;
    const autorId = req.user.id;
    const autorNome = req.user.name || req.user.nome_completo || 'Usuário';

    if (!conteudo || conteudo.trim().length === 0) {
      return res.status(400).json(errorResponse('Conteúdo do comentário é obrigatório'));
    }

    if (conteudo.length > 500) {
      return res.status(400).json(errorResponse('Comentário muito longo (máximo 500 caracteres)'));
    }

    // Verificar se o post existe
    const postCheck = await pool.query(
      'SELECT id FROM feed_posts WHERE id = $1 AND ativo = true',
      [postId]
    );

    if (postCheck.rows.length === 0) {
      return res.status(404).json(errorResponse('Post não encontrado'));
    }

    // Inserir comentário
    const result = await pool.query(`
      INSERT INTO comentarios_feed (post_id, autor_id, autor_nome, conteudo)
      VALUES ($1, $2, $3, $4)
      RETURNING *
    `, [postId, autorId, autorNome, conteudo.trim()]);

    // Atualizar contador de comentários no post
    await pool.query(`
      UPDATE feed_posts 
      SET comentarios = comentarios + 1, data_atualizacao = CURRENT_TIMESTAMP
      WHERE id = $1
    `, [postId]);

    const comentario = formatObjectDates(result.rows[0]);

    res.status(201).json(successResponse(comentario, 'Comentário criado com sucesso'));
  } catch (error) {
    console.error('Erro ao criar comentário:', error);
    res.status(500).json(errorResponse('Erro interno do servidor', error.message));
  }
});

// Atualizar comentário
router.put('/comentarios/:comentarioId', authenticateToken, async (req, res) => {
  try {
    const { comentarioId } = req.params;
    const { conteudo } = req.body;
    const autorId = req.user.id;

    if (!conteudo || conteudo.trim().length === 0) {
      return res.status(400).json(errorResponse('Conteúdo do comentário é obrigatório'));
    }

    if (conteudo.length > 500) {
      return res.status(400).json(errorResponse('Comentário muito longo (máximo 500 caracteres)'));
    }

    const result = await pool.query(`
      UPDATE comentarios_feed 
      SET conteudo = $1, data_atualizacao = CURRENT_TIMESTAMP
      WHERE id = $2 AND autor_id = $3 AND ativo = true
      RETURNING *
    `, [conteudo.trim(), comentarioId, autorId]);

    if (result.rows.length === 0) {
      return res.status(404).json(errorResponse('Comentário não encontrado ou sem permissão'));
    }

    const comentario = formatObjectDates(result.rows[0]);

    res.json(successResponse(comentario, 'Comentário atualizado com sucesso'));
  } catch (error) {
    console.error('Erro ao atualizar comentário:', error);
    res.status(500).json(errorResponse('Erro interno do servidor', error.message));
  }
});

// Remover comentário
router.delete('/comentarios/:comentarioId', authenticateToken, async (req, res) => {
  try {
    const { comentarioId } = req.params;
    const autorId = req.user.id;

    // Buscar comentário para obter o post_id
    const comentarioCheck = await pool.query(
      'SELECT post_id FROM comentarios_feed WHERE id = $1 AND autor_id = $2 AND ativo = true',
      [comentarioId, autorId]
    );

    if (comentarioCheck.rows.length === 0) {
      return res.status(404).json(errorResponse('Comentário não encontrado ou sem permissão'));
    }

    const postId = comentarioCheck.rows[0].post_id;

    // Remover comentário (soft delete)
    await pool.query(`
      UPDATE comentarios_feed 
      SET ativo = false, data_atualizacao = CURRENT_TIMESTAMP
      WHERE id = $1
    `, [comentarioId]);

    // Atualizar contador de comentários no post
    await pool.query(`
      UPDATE feed_posts 
      SET comentarios = GREATEST(comentarios - 1, 0), data_atualizacao = CURRENT_TIMESTAMP
      WHERE id = $1
    `, [postId]);

    res.json(successResponse({ id: parseInt(comentarioId) }, 'Comentário removido com sucesso'));
  } catch (error) {
    console.error('Erro ao remover comentário:', error);
    res.status(500).json(errorResponse('Erro interno do servidor', error.message));
  }
});

module.exports = router;',
  port: parseInt(process.env.POSTGRES_PORT || '5432'),
  database: process.env.POSTGRES_DB || 'movemarias',
  user: process.env.POSTGRES_USER || 'postgres',
  password: process.env.POSTGRES_PASSWORD || '15002031',
  max: 20,
  min: 2,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 5000,
  ssl: process.env.NODE_ENV === 'production' ? { 
    rejectUnauthorized: false 
  } : false,
});

// Listar todos os posts do feed
router.get('/', authenticateToken, async (req, res) => {
  try {
    const { tipo, limit = 50, offset = 0 } = req.query;
    
    console.log('Buscando posts do feed...');
    
    let query = `
      SELECT 
        id,
        tipo,
        titulo,
        conteudo,
        autor_id,
        autor_nome,
        autor_foto,
        imagem_url,
        curtidas,
        comentarios,
        ativo,
        data_criacao,
        data_atualizacao
      FROM feed_posts 
      WHERE ativo = true
    `;
    
    const queryParams = [];
    
    if (tipo) {
      query += ` AND tipo = $${queryParams.length + 1}`;
      queryParams.push(tipo);
    }
    
    query += ` ORDER BY data_criacao DESC LIMIT $${queryParams.length + 1} OFFSET $${queryParams.length + 2}`;
    queryParams.push(parseInt(limit), parseInt(offset));
    
    console.log('Executando query:', query);
    console.log('Parâmetros:', queryParams);
    
    const result = await pool.query(query, queryParams);
    
    console.log('Resultado da query:', result.rows.length, 'posts encontrados');
    
    res.json(successResponse(result.rows, 'Posts do feed recuperados com sucesso'));
  } catch (error) {
    console.error('Erro ao buscar posts do feed:', error);
    res.status(500).json(errorResponse('Erro interno do servidor', error.message));
  }
});

// Buscar post específico do feed
router.get('/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      SELECT 
        id,
        tipo,
        titulo,
        conteudo,
        autor_id,
        autor_nome,
        autor_foto,
        imagem_url,
        curtidas,
        comentarios,
        ativo,
        data_criacao,
        data_atualizacao
      FROM feed_posts 
      WHERE id = $1 AND ativo = true
    `, [id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json(errorResponse('Post não encontrado'));
    }
    
    res.json(successResponse(result.rows[0], 'Post do feed recuperado com sucesso'));
  } catch (error) {
    console.error('Erro ao buscar post do feed:', error);
    res.status(500).json(errorResponse('Erro interno do servidor', error.message));
  }
});

// Criar novo post no feed
router.post('/', authenticateToken, async (req, res) => {
  try {
    const {
      tipo,
      titulo,
      conteudo,
      autor_nome,
      autor_foto,
      imagem_url
    } = req.body;
    
    // Validações
    if (!tipo || !titulo || !conteudo || !autor_nome) {
      return res.status(400).json(errorResponse('Campos obrigatórios: tipo, titulo, conteudo, autor_nome'));
    }
    
    if (!['anuncio', 'evento', 'noticia', 'conquista'].includes(tipo)) {
      return res.status(400).json(errorResponse('Tipo deve ser: anuncio, evento, noticia ou conquista'));
    }
    
    const result = await pool.query(`
      INSERT INTO feed_posts (
        tipo, titulo, conteudo, autor_id, autor_nome, autor_foto, imagem_url
      ) VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING *
    `, [tipo, titulo, conteudo, req.user.id, autor_nome, autor_foto, imagem_url]);
    
    res.status(201).json(successResponse(result.rows[0], 'Post criado com sucesso'));
  } catch (error) {
    console.error('Erro ao criar post:', error);
    res.status(500).json(errorResponse('Erro interno do servidor', error.message));
  }
});

// Atualizar post do feed
router.put('/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const {
      tipo,
      titulo,
      conteudo,
      autor_nome,
      autor_foto,
      imagem_url
    } = req.body;
    
    // Verificar se o post existe
    const existingPost = await pool.query(
      'SELECT * FROM feed_posts WHERE id = $1',
      [id]
    );
    
    if (existingPost.rows.length === 0) {
      return res.status(404).json(errorResponse('Post não encontrado'));
    }
    
    // Validações
    if (tipo && !['anuncio', 'evento', 'noticia', 'conquista'].includes(tipo)) {
      return res.status(400).json(errorResponse('Tipo deve ser: anuncio, evento, noticia ou conquista'));
    }
    
    const result = await pool.query(`
      UPDATE feed_posts 
      SET 
        tipo = COALESCE($1, tipo),
        titulo = COALESCE($2, titulo),
        conteudo = COALESCE($3, conteudo),
        autor_nome = COALESCE($4, autor_nome),
        autor_foto = COALESCE($5, autor_foto),
        imagem_url = COALESCE($6, imagem_url),
        data_atualizacao = CURRENT_TIMESTAMP
      WHERE id = $7
      RETURNING *
    `, [tipo, titulo, conteudo, autor_nome, autor_foto, imagem_url, id]);
    
    res.json(successResponse(result.rows[0], 'Post atualizado com sucesso'));
  } catch (error) {
    console.error('Erro ao atualizar post:', error);
    res.status(500).json(errorResponse('Erro interno do servidor', error.message));
  }
});

// Curtir/descurtir post
router.post('/:id/curtir', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    
    // Verificar se o post existe
    const existingPost = await pool.query(
      'SELECT * FROM feed_posts WHERE id = $1 AND ativo = true',
      [id]
    );
    
    if (existingPost.rows.length === 0) {
      return res.status(404).json(errorResponse('Post não encontrado'));
    }
    
    // Incrementar curtidas
    const result = await pool.query(`
      UPDATE feed_posts 
      SET curtidas = curtidas + 1
      WHERE id = $1
      RETURNING curtidas
    `, [id]);
    
    res.json(successResponse({ 
      id: parseInt(id), 
      curtidas: result.rows[0].curtidas 
    }, 'Post curtido com sucesso'));
  } catch (error) {
    console.error('Erro ao curtir post:', error);
    res.status(500).json(errorResponse('Erro interno do servidor', error.message));
  }
});

// Compartilhar post (incrementa contador)
router.post('/:id/compartilhar', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    
    // Verificar se o post existe
    const existingPost = await pool.query(
      'SELECT * FROM feed_posts WHERE id = $1 AND ativo = true',
      [id]
    );
    
    if (existingPost.rows.length === 0) {
      return res.status(404).json(errorResponse('Post não encontrado'));
    }
    
    res.json(successResponse({ 
      id: parseInt(id),
      compartilhado: true 
    }, 'Post compartilhado com sucesso'));
  } catch (error) {
    console.error('Erro ao compartilhar post:', error);
    res.status(500).json(errorResponse('Erro interno do servidor', error.message));
  }
});

// Desativar post
router.delete('/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await pool.query(`
      UPDATE feed_posts 
      SET ativo = false, data_atualizacao = CURRENT_TIMESTAMP
      WHERE id = $1
      RETURNING id
    `, [id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json(errorResponse('Post não encontrado'));
    }
    
    res.json(successResponse({ id: parseInt(id) }, 'Post removido com sucesso'));
  } catch (error) {
    console.error('Erro ao remover post:', error);
    res.status(500).json(errorResponse('Erro interno do servidor', error.message));
  }
});

// Estatísticas do feed
router.get('/stats/summary', authenticateToken, async (req, res) => {
  try {
    const statsQuery = await pool.query(`
      SELECT 
        COUNT(*) as total_posts,
        COUNT(CASE WHEN tipo = 'anuncio' THEN 1 END) as total_anuncios,
        COUNT(CASE WHEN tipo = 'evento' THEN 1 END) as total_eventos,
        COUNT(CASE WHEN tipo = 'noticia' THEN 1 END) as total_noticias,
        COUNT(CASE WHEN tipo = 'conquista' THEN 1 END) as total_conquistas,
        SUM(curtidas) as total_curtidas,
        SUM(comentarios) as total_comentarios,
        AVG(curtidas) as media_curtidas
      FROM feed_posts 
      WHERE ativo = true
    `);
    
    const recentQuery = await pool.query(`
      SELECT COUNT(*) as posts_recentes
      FROM feed_posts 
      WHERE ativo = true 
      AND data_criacao >= NOW() - INTERVAL '30 days'
    `);
    
    const stats = {
      ...statsQuery.rows[0],
      posts_recentes: recentQuery.rows[0].posts_recentes,
      media_curtidas: parseFloat(statsQuery.rows[0].media_curtidas || 0).toFixed(1)
    };
    
    // Converter strings para números
    Object.keys(stats).forEach(key => {
      if (key !== 'media_curtidas') {
        stats[key] = parseInt(stats[key]) || 0;
      }
    });
    
    res.json(successResponse(stats, 'Estatísticas do feed recuperadas com sucesso'));
  } catch (error) {
    console.error('Erro ao buscar estatísticas do feed:', error);
    res.status(500).json(errorResponse('Erro interno do servidor', error.message));
  }
});

module.exports = router;
